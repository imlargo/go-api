package services

import (
	"crypto/rand"
	"encoding/base64"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/nicolailuther/butter/internal/dto"
	"github.com/nicolailuther/butter/internal/enums"
	"github.com/nicolailuther/butter/internal/models"
	"gorm.io/gorm"
)

const (
	MaxActiveCodesPerUser        = 10
	AutoGeneratedCodeLength      = 8
	DefaultReferredUsersPageSize = 20
	MaxReferredUsersPageSize     = 1000
	MinReferredUsersPage         = 1
)

type ReferralService interface {
	CreateReferralCode(userID uint, req *dto.CreateReferralCodeRequest) (*dto.ReferralCodeResponse, error)
	GetReferralCode(id uint, userID uint) (*dto.ReferralCodeResponse, error)
	GetUserReferralCodes(userID uint) ([]*dto.ReferralCodeResponse, error)
	UpdateReferralCode(id uint, userID uint, req *dto.UpdateReferralCodeRequest) (*dto.ReferralCodeResponse, error)
	DeleteReferralCode(id uint, userID uint) error
	GetReferralMetrics(userID uint) (*dto.ReferralMetricsResponse, error)
	TrackClick(code string) error
	TrackRegistration(code string) error
	CheckCodeAvailability(code string) (*dto.CheckCodeAvailabilityResponse, error)
	GenerateUniqueCode() (string, error)
	GetReferredUsers(userID uint, filter *dto.ReferredUsersFilter) (*dto.ReferredUsersListResponse, error)
}

type referralService struct {
	*Service
}

func NewReferralService(s *Service) ReferralService {
	return &referralService{
		Service: s,
	}
}

func (s *referralService) CreateReferralCode(userID uint, req *dto.CreateReferralCodeRequest) (*dto.ReferralCodeResponse, error) {
	// Get user to check permissions
	user, err := s.store.Users.GetByID(userID)
	if err != nil {
		return nil, fmt.Errorf("error checking user permissions: %w", err)
	}

	// Only admins and agencies can create referral codes
	if user.Role != enums.UserRoleAdmin && user.Role != enums.UserRoleAgency {
		return nil, errors.New("only admin and agency users can create referral codes")
	}

	// Check if discount percentage is provided - only admins can set discount percentages
	if req.DiscountPercentage != nil && *req.DiscountPercentage > 0 {
		if user.Role != enums.UserRoleAdmin {
			return nil, errors.New("only admin users can create referral codes with discounts")
		}

		// Validate discount percentage
		if *req.DiscountPercentage < 0 || *req.DiscountPercentage > 100 {
			return nil, errors.New("discount percentage must be between 0 and 100")
		}
	}

	// Check if user has reached the limit
	activeCount, err := s.store.ReferralCode.CountActiveByUserID(userID)
	if err != nil {
		return nil, fmt.Errorf("error checking active codes: %w", err)
	}

	if activeCount >= MaxActiveCodesPerUser {
		return nil, errors.New("maximum number of active codes reached (10)")
	}

	// Generate code if not provided
	code := req.Code
	if code == "" {

		// code, err = s.GenerateUniqueCode()
		// if err != nil {
		// 	return nil, fmt.Errorf("error generating code: %w", err)
		// }
		return nil, errors.New("code is required")
	}

	// Validate code format
	if !isValidCodeFormat(code) {
		return nil, errors.New("invalid code format: only alphanumeric characters and hyphens allowed")
	}

	// Check if code already exists
	exists, err := s.store.ReferralCode.CheckCodeExists(code)
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return nil, fmt.Errorf("error checking code existence: %w", err)
	}
	if exists {
		return nil, errors.New("code already exists")
	}

	// Validate expiration date
	if req.ExpiresAt != nil && req.ExpiresAt.Before(time.Now()) {
		return nil, errors.New("expiration date must be in the future")
	}

	// Create referral code
	referralCode := &models.ReferralCode{
		Code:               code,
		Description:        req.Description,
		Status:             enums.ReferralCodeStatusActive,
		ExpiresAt:          req.ExpiresAt,
		UsageLimit:         req.UsageLimit,
		DiscountPercentage: req.DiscountPercentage,
		UserID:             userID,
		Clicks:             0,
		Registrations:      0,
	}

	if err := s.store.ReferralCode.Create(referralCode); err != nil {
		return nil, fmt.Errorf("error creating referral code: %w", err)
	}

	isAdmin := user.Role == enums.UserRoleAdmin
	return s.toReferralCodeResponse(referralCode, isAdmin), nil
}

func (s *referralService) GetReferralCode(id uint, userID uint) (*dto.ReferralCodeResponse, error) {
	code, err := s.store.ReferralCode.GetByID(id)
	if err != nil {
		return nil, fmt.Errorf("referral code not found: %w", err)
	}

	// Get user to check if admin
	user, err := s.store.Users.GetByID(userID)
	if err != nil {
		return nil, fmt.Errorf("error checking user permissions: %w", err)
	}

	// Check ownership (admins can access any code)
	if user.Role != enums.UserRoleAdmin && code.UserID != userID {
		return nil, errors.New("unauthorized: code belongs to another user")
	}

	isAdmin := user.Role == enums.UserRoleAdmin
	return s.toReferralCodeResponse(code, isAdmin), nil
}

func (s *referralService) GetUserReferralCodes(userID uint) ([]*dto.ReferralCodeResponse, error) {
	// Get user to check if admin
	user, err := s.store.Users.GetByID(userID)
	if err != nil {
		return nil, fmt.Errorf("error checking user permissions: %w", err)
	}

	var codes []*models.ReferralCode
	// Admins can see all referral codes
	if user.Role == enums.UserRoleAdmin {
		codes, err = s.store.ReferralCode.GetAll()
	} else {
		// Other users (agencies) can only see their own codes
		codes, err = s.store.ReferralCode.GetByUserID(userID)
	}

	if err != nil {
		return nil, fmt.Errorf("error fetching referral codes: %w", err)
	}

	responses := make([]*dto.ReferralCodeResponse, len(codes))
	isAdmin := user.Role == enums.UserRoleAdmin
	for i, code := range codes {
		responses[i] = s.toReferralCodeResponse(code, isAdmin)
	}

	return responses, nil
}

func (s *referralService) UpdateReferralCode(id uint, userID uint, req *dto.UpdateReferralCodeRequest) (*dto.ReferralCodeResponse, error) {
	code, err := s.store.ReferralCode.GetByID(id)
	if err != nil {
		return nil, fmt.Errorf("referral code not found: %w", err)
	}

	// Get user to check permissions
	user, err := s.store.Users.GetByID(userID)
	if err != nil {
		return nil, fmt.Errorf("error checking user permissions: %w", err)
	}

	// Check ownership (admins can update any code)
	if user.Role != enums.UserRoleAdmin && code.UserID != userID {
		return nil, errors.New("unauthorized: code belongs to another user")
	}

	// Check if discount percentage is being updated - only admins can do this
	if req.DiscountPercentage != nil {
		if user.Role != enums.UserRoleAdmin {
			return nil, errors.New("only admin users can update discount percentages")
		}

		// Validate discount percentage
		if *req.DiscountPercentage < 0 || *req.DiscountPercentage > 100 {
			return nil, errors.New("discount percentage must be between 0 and 100")
		}
	}

	// Validate expiration date
	if req.ExpiresAt != nil && req.ExpiresAt.Before(time.Now()) {
		return nil, errors.New("expiration date must be in the future")
	}

	// Update fields
	code.Description = req.Description
	if req.Status != "" {
		code.Status = req.Status
	}
	code.ExpiresAt = req.ExpiresAt
	code.UsageLimit = req.UsageLimit
	if req.DiscountPercentage != nil {
		// If discount percentage is being changed and code has been used, prevent the change
		if code.DiscountPercentage != nil && *code.DiscountPercentage != *req.DiscountPercentage {
			if code.Registrations > 0 {
				return nil, errors.New("cannot change discount percentage on a code that has been used")
			}
			// Clear the Stripe coupon ID so a new coupon will be created with the updated percentage
			code.StripeCouponID = ""
		}
		code.DiscountPercentage = req.DiscountPercentage
	}

	if err := s.store.ReferralCode.Update(code); err != nil {
		return nil, fmt.Errorf("error updating referral code: %w", err)
	}

	return s.toReferralCodeResponse(code, user.Role == enums.UserRoleAdmin), nil
}

func (s *referralService) DeleteReferralCode(id uint, userID uint) error {
	code, err := s.store.ReferralCode.GetByID(id)
	if err != nil {
		return fmt.Errorf("referral code not found: %w", err)
	}

	// Get user to check permissions
	user, err := s.store.Users.GetByID(userID)
	if err != nil {
		return fmt.Errorf("error checking user permissions: %w", err)
	}

	// Check ownership (admins can delete any code)
	if user.Role != enums.UserRoleAdmin && code.UserID != userID {
		return errors.New("unauthorized: code belongs to another user")
	}

	if err := s.store.ReferralCode.Delete(id); err != nil {
		return fmt.Errorf("error deleting referral code: %w", err)
	}

	return nil
}

func (s *referralService) GetReferralMetrics(userID uint) (*dto.ReferralMetricsResponse, error) {
	// Get user to check if admin
	user, err := s.store.Users.GetByID(userID)
	if err != nil {
		return nil, fmt.Errorf("error checking user permissions: %w", err)
	}

	var codes []*models.ReferralCode
	// Admins can see metrics for all codes
	if user.Role == enums.UserRoleAdmin {
		codes, err = s.store.ReferralCode.GetAll()
	} else {
		codes, err = s.store.ReferralCode.GetByUserID(userID)
	}

	if err != nil {
		return nil, fmt.Errorf("error fetching referral codes: %w", err)
	}

	totalCodes := len(codes)
	activeCodes := 0
	totalClicks := 0
	totalRegistrations := 0

	now := time.Now()
	for _, code := range codes {
		totalClicks += code.Clicks
		totalRegistrations += code.Registrations

		// Check if code is active
		if code.Status == enums.ReferralCodeStatusActive &&
			(code.ExpiresAt == nil || code.ExpiresAt.After(now)) {
			activeCodes++
		}
	}

	conversionRate := 0.0
	if totalClicks > 0 {
		conversionRate = (float64(totalRegistrations) / float64(totalClicks)) * 100
	}

	return &dto.ReferralMetricsResponse{
		TotalCodes:         totalCodes,
		ActiveCodes:        activeCodes,
		TotalClicks:        totalClicks,
		TotalRegistrations: totalRegistrations,
		ConversionRate:     conversionRate,
	}, nil
}

func (s *referralService) TrackClick(code string) error {
	referralCode, err := s.store.ReferralCode.GetByCode(code)
	if err != nil {
		return fmt.Errorf("referral code not found: %w", err)
	}

	// Check if code is active
	if referralCode.Status != enums.ReferralCodeStatusActive {
		return errors.New("referral code is not active")
	}

	// Check if code has expired
	if referralCode.ExpiresAt != nil && referralCode.ExpiresAt.Before(time.Now()) {
		// Update status to expired
		_ = s.store.ReferralCode.UpdateStatus(referralCode.ID, enums.ReferralCodeStatusExpired)
		return errors.New("referral code has expired")
	}

	// Increment clicks
	if err := s.store.ReferralCode.IncrementClicks(referralCode.ID); err != nil {
		return fmt.Errorf("error incrementing clicks: %w", err)
	}

	return nil
}

func (s *referralService) TrackRegistration(code string) error {
	referralCode, err := s.store.ReferralCode.GetByCode(code)
	if err != nil {
		return fmt.Errorf("referral code not found: %w", err)
	}

	// Check if code is active
	if referralCode.Status != enums.ReferralCodeStatusActive {
		return errors.New("referral code is not active")
	}

	// Check if code has expired
	if referralCode.ExpiresAt != nil && referralCode.ExpiresAt.Before(time.Now()) {
		_ = s.store.ReferralCode.UpdateStatus(referralCode.ID, enums.ReferralCodeStatusExpired)
		return errors.New("referral code has expired")
	}

	// Check usage limit
	if referralCode.UsageLimit != nil && referralCode.Registrations >= *referralCode.UsageLimit {
		return errors.New("referral code has reached its usage limit")
	}

	// Increment registrations
	if err := s.store.ReferralCode.IncrementRegistrations(referralCode.ID); err != nil {
		return fmt.Errorf("error incrementing registrations: %w", err)
	}

	// Check if limit reached and send notification
	if referralCode.UsageLimit != nil && (referralCode.Registrations+1) >= *referralCode.UsageLimit {
		go s.sendLimitReachedNotification(referralCode.UserID, referralCode.Code)
	}

	// Send registration notification
	go s.sendRegistrationNotification(referralCode.UserID, referralCode.Code)

	return nil
}

func (s *referralService) CheckCodeAvailability(code string) (*dto.CheckCodeAvailabilityResponse, error) {
	if code == "" {
		return &dto.CheckCodeAvailabilityResponse{
			Available: false,
			Message:   "Code cannot be empty",
		}, nil
	}

	if !isValidCodeFormat(code) {
		return &dto.CheckCodeAvailabilityResponse{
			Available: false,
			Message:   "Invalid code format: only alphanumeric characters and hyphens allowed",
		}, nil
	}

	exists, err := s.store.ReferralCode.CheckCodeExists(code)
	if err != nil {
		return nil, fmt.Errorf("error checking code existence: %w", err)
	}

	if exists {
		return &dto.CheckCodeAvailabilityResponse{
			Available: false,
			Message:   "Code already exists",
		}, nil
	}

	return &dto.CheckCodeAvailabilityResponse{
		Available: true,
		Message:   "Code is available",
	}, nil
}

func (s *referralService) GenerateUniqueCode() (string, error) {
	maxAttempts := 5
	for i := 0; i < maxAttempts; i++ {
		code, err := generateRandomCode(AutoGeneratedCodeLength)
		if err != nil {
			return "", err
		}
		exists, err := s.store.ReferralCode.CheckCodeExists(code)
		if err != nil {
			return "", err
		}
		if !exists {
			return code, nil
		}
	}
	return "", errors.New("failed to generate unique code after multiple attempts")
}

// Helper functions

func (s *referralService) toReferralCodeResponse(code *models.ReferralCode, isAdmin bool) *dto.ReferralCodeResponse {
	conversionRate := 0.0
	if code.Clicks > 0 {
		conversionRate = (float64(code.Registrations) / float64(code.Clicks)) * 100
	}

	var remainingUses *int
	if code.UsageLimit != nil {
		remaining := *code.UsageLimit - code.Registrations
		if remaining < 0 {
			remaining = 0
		}
		remainingUses = &remaining
	}

	// Build referral link
	baseURL := "https://app.hellobutter.io"
	referralLink := fmt.Sprintf("%s/ref/%s", baseURL, code.Code)

	response := &dto.ReferralCodeResponse{
		ID:                 code.ID,
		Code:               code.Code,
		Description:        code.Description,
		Status:             code.Status,
		ExpiresAt:          code.ExpiresAt,
		UsageLimit:         code.UsageLimit,
		Clicks:             code.Clicks,
		Registrations:      code.Registrations,
		DiscountPercentage: code.DiscountPercentage,
		UserID:             code.UserID,
		CreatedAt:          code.CreatedAt,
		UpdatedAt:          code.UpdatedAt,
		ReferralLink:       referralLink,
		ConversionRate:     conversionRate,
		RemainingUses:      remainingUses,
	}

	// Populate user information only for admins
	if isAdmin && code.User != nil {
		if code.User.Name != "" {
			response.UserName = code.User.Name
		}
		if code.User.Email != "" {
			response.UserEmail = code.User.Email
		}
	}

	return response
}

func (s *referralService) sendRegistrationNotification(userID uint, code string) {
	notification := &models.Notification{
		Title:       "New Referral Registration",
		Description: fmt.Sprintf("Someone registered using your referral code: %s", code),
		Category:    enums.NotificationTypeReferral,
		UserID:      userID,
		Read:        false,
	}
	_ = s.store.Notifications.Create(notification)
}

func (s *referralService) sendLimitReachedNotification(userID uint, code string) {
	notification := &models.Notification{
		Title:       "Referral Code Limit Reached",
		Description: fmt.Sprintf("Your referral code '%s' has reached its usage limit", code),
		Category:    enums.NotificationTypeReferral,
		UserID:      userID,
		Read:        false,
	}
	_ = s.store.Notifications.Create(notification)
}

func (s *referralService) sendExpirationWarningNotification(userID uint, code string) {
	notification := &models.Notification{
		Title:       "Referral Code Expiring Soon",
		Description: fmt.Sprintf("Your referral code '%s' will expire in 1 day", code),
		Category:    enums.NotificationTypeReferral,
		UserID:      userID,
		Read:        false,
	}
	_ = s.store.Notifications.Create(notification)
}

func isValidCodeFormat(code string) bool {
	if len(code) == 0 || len(code) > 10 {
		return false
	}
	for _, char := range code {
		if !((char >= 'a' && char <= 'z') ||
			(char >= 'A' && char <= 'Z') ||
			(char >= '0' && char <= '9') ||
			char == '-') {
			return false
		}
	}
	return true
}

func generateRandomCode(length int) (string, error) {
	b := make([]byte, length)
	if _, err := rand.Read(b); err != nil {
		return "", fmt.Errorf("failed to generate random bytes: %w", err)
	}
	code := base64.URLEncoding.EncodeToString(b)
	code = strings.ReplaceAll(code, "_", "")
	code = strings.ReplaceAll(code, "-", "")
	code = strings.ToUpper(code)
	if len(code) > length {
		code = code[:length]
	}
	return code, nil
}

// calculateMonthsBetween calculates the number of months between two dates
// using calendar month difference for more accurate subscription month counting
func calculateMonthsBetween(start, end time.Time) int {
	yearDiff := end.Year() - start.Year()
	monthDiff := int(end.Month()) - int(start.Month())
	dayDiff := end.Day() - start.Day()

	months := yearDiff*12 + monthDiff

	// If the end day is before the start day, subtract a month
	// (e.g., Jan 15 to Feb 10 is less than a full month)
	if dayDiff < 0 {
		months--
	}

	// Handle edge cases where end is before start
	if months < 0 {
		return 0
	}

	return months
}

// GetReferredUsers returns a paginated list of users who registered using the owner's referral codes
func (s *referralService) GetReferredUsers(userID uint, filter *dto.ReferredUsersFilter) (*dto.ReferredUsersListResponse, error) {
	// Get user to check if admin
	user, err := s.store.Users.GetByID(userID)
	if err != nil {
		return nil, fmt.Errorf("error checking user permissions: %w", err)
	}

	// Get all referral codes for this user (or all if admin)
	var codes []*models.ReferralCode
	if user.Role == enums.UserRoleAdmin {
		codes, err = s.store.ReferralCode.GetAll()
	} else {
		codes, err = s.store.ReferralCode.GetByUserID(userID)
	}
	if err != nil {
		return nil, fmt.Errorf("error fetching referral codes: %w", err)
	}

	// Set default pagination
	page := filter.Page
	pageSize := filter.PageSize
	if page < MinReferredUsersPage {
		page = MinReferredUsersPage
	}
	if pageSize < 1 || pageSize > MaxReferredUsersPageSize {
		pageSize = DefaultReferredUsersPageSize
	}
	offset := (page - 1) * pageSize

	// Collect all referral code IDs and build a map from ID to code string
	var referralCodeIDs []uint
	referralCodeMap := make(map[uint]string)
	for _, code := range codes {
		referralCodeIDs = append(referralCodeIDs, code.ID)
		referralCodeMap[code.ID] = code.Code
	}

	if len(referralCodeIDs) == 0 {
		// No referral codes, return empty result
		return &dto.ReferredUsersListResponse{
			Users:    []*dto.ReferredUserResponse{},
			Summary:  dto.ReferredUsersSummary{},
			Total:    0,
			Page:     page,
			PageSize: pageSize,
		}, nil
	}

	// Get all referred users with filters
	var allUsers []*models.User
	var totalCount int64

	// Build query for all referral codes
	query := s.store.DB.Model(&models.User{}).Where("referral_code_id IN ?", referralCodeIDs)

	// Apply status filter
	if filter.Status != "" {
		switch filter.Status {
		case "active":
			query = query.Where("subscription_status = ?", "active")
		case "canceled":
			query = query.Where("subscription_status = ?", "canceled")
		case "inactive":
			query = query.Where("subscription_status IS NULL OR subscription_status = '' OR subscription_status NOT IN ('active', 'canceled')")
		}
	}

	// Apply date filters
	if filter.DateFrom != "" {
		parsedFrom, parseErr := time.Parse("2006-01-02", filter.DateFrom)
		if parseErr == nil {
			query = query.Where("created_at >= ?", parsedFrom)
		}
	}
	if filter.DateTo != "" {
		parsedTo, parseErr := time.Parse("2006-01-02", filter.DateTo)
		if parseErr == nil {
			parsedTo = parsedTo.Add(24 * time.Hour)
			query = query.Where("created_at < ?", parsedTo)
		}
	}

	// Get total count
	if err := query.Count(&totalCount).Error; err != nil {
		return nil, fmt.Errorf("error counting referred users: %w", err)
	}

	// Apply sorting
	orderClause := "created_at DESC"
	if filter.SortBy != "" {
		validSortFields := map[string]string{
			"name":                "name",
			"email":               "email",
			"registered_at":       "created_at",
			"subscription_status": "subscription_status",
			"plan_type":           "tier_level",
		}
		if field, ok := validSortFields[filter.SortBy]; ok {
			order := "ASC"
			if filter.SortOrder == "desc" {
				order = "DESC"
			}
			orderClause = field + " " + order
		}
	}
	query = query.Order(orderClause)

	// Apply pagination
	query = query.Limit(pageSize).Offset(offset)

	if err := query.Find(&allUsers).Error; err != nil {
		return nil, fmt.Errorf("error fetching referred users: %w", err)
	}

	// Collect all user IDs for batch loading subscriptions
	userIDs := make([]uint, len(allUsers))
	for i, u := range allUsers {
		userIDs[i] = u.ID
	}

	// Batch-load all subscriptions for these users to avoid N+1 queries
	allSubscriptions, subErr := s.store.Subscriptions.GetUsersSubscriptions(userIDs)
	if subErr != nil {
		s.logger.Warnf("Failed to batch-load subscriptions for referred users: %v", subErr)
		// Continue with empty subscriptions - users will show 0 months subscribed
		allSubscriptions = []*models.Subscription{}
	}

	// Build a map from user ID to their subscriptions
	subscriptionsByUser := make(map[uint][]*models.Subscription)
	for _, sub := range allSubscriptions {
		subscriptionsByUser[sub.UserID] = append(subscriptionsByUser[sub.UserID], sub)
	}

	// Get subscriptions for calculating months subscribed
	userResponses := make([]*dto.ReferredUserResponse, len(allUsers))
	totalMonths := 0

	for i, u := range allUsers {
		// Get subscription info from the pre-loaded map
		subscriptions := subscriptionsByUser[u.ID]

		monthsSubscribed := 0
		var currentPeriodEnd *time.Time

		for _, sub := range subscriptions {
			if sub.SubscriptionType == models.SubscriptionTypeTier {
				// Calculate months from subscription history
				start := sub.CurrentPeriodStart
				end := sub.CurrentPeriodEnd

				if sub.Status == models.SubscriptionStatusCanceled && sub.CanceledAt != nil {
					end = *sub.CanceledAt
				}

				if !start.IsZero() && !end.IsZero() {
					// Calculate months using calendar month difference for better accuracy
					// calculateMonthsBetween handles negative values by returning 0
					months := calculateMonthsBetween(start, end)
					if months == 0 {
						// At least 1 month if there's an active period
						months = 1
					}
					monthsSubscribed += months
				}

				if sub.Status == models.SubscriptionStatusActive {
					currentPeriodEnd = &sub.CurrentPeriodEnd
				}
			}
		}

		// Determine subscription status
		subscriptionStatus := dto.ReferredUserSubscriptionStatusInactive
		if u.SubscriptionStatus == "active" {
			subscriptionStatus = dto.ReferredUserSubscriptionStatusActive
		} else if u.SubscriptionStatus == "canceled" {
			subscriptionStatus = dto.ReferredUserSubscriptionStatusCanceled
		}

		// Determine plan type
		planType := u.TierLevel.String()

		userResponses[i] = &dto.ReferredUserResponse{
			ID:                 u.ID,
			Name:               u.Name,
			Email:              u.Email,
			RegisteredAt:       u.CreatedAt,
			PlanType:           planType,
			SubscriptionStatus: subscriptionStatus,
			MonthsSubscribed:   monthsSubscribed,
			CurrentPeriodEnd:   currentPeriodEnd,
			ReferralCode:       referralCodeMap[u.ReferralCodeID],
		}

		totalMonths += monthsSubscribed
	}

	// Calculate summary statistics (without filters) using conditional aggregation in single query
	type summaryCounts struct {
		TotalReferred int64
		ActiveCount   int64
		CanceledCount int64
	}
	var counts summaryCounts
	err = s.store.DB.Model(&models.User{}).
		Select(
			"COUNT(*) as total_referred, "+
				"COUNT(CASE WHEN subscription_status = ? THEN 1 END) as active_count, "+
				"COUNT(CASE WHEN subscription_status = ? THEN 1 END) as canceled_count",
			"active", "canceled").
		Where("referral_code_id IN ?", referralCodeIDs).
		Scan(&counts).Error
	if err != nil {
		return nil, fmt.Errorf("error calculating summary statistics: %w", err)
	}

	inactiveCount := counts.TotalReferred - counts.ActiveCount - counts.CanceledCount

	return &dto.ReferredUsersListResponse{
		Users: userResponses,
		Summary: dto.ReferredUsersSummary{
			TotalReferred:        int(counts.TotalReferred),
			ActiveSubscribers:    int(counts.ActiveCount),
			CanceledSubscribers:  int(counts.CanceledCount),
			InactiveSubscribers:  int(inactiveCount),
			TotalMonthsGenerated: totalMonths,
		},
		Total:    totalCount,
		Page:     page,
		PageSize: pageSize,
	}, nil
}
